// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package plugin

import (
	"sync"
)

// Ensure, that HasherMock does implement Hasher.
// If this is not the case, regenerate this file with moq.
var _ Hasher = &HasherMock{}

// HasherMock is a mock implementation of Hasher.
//
//     func TestSomethingThatUsesHasher(t *testing.T) {
//
//         // make and configure a mocked Hasher
//         mockedHasher := &HasherMock{
//             PluginerHashFunc: func(config interface{}) (string, error) {
// 	               panic("mock out the PluginerHash method")
//             },
//         }
//
//         // use mockedHasher in code that requires Hasher
//         // and then make assertions.
//
//     }
type HasherMock struct {
	// PluginerHashFunc mocks the PluginerHash method.
	PluginerHashFunc func(config interface{}) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// PluginerHash holds details about calls to the PluginerHash method.
		PluginerHash []struct {
			// Config is the config argument value.
			Config interface{}
		}
	}
	lockPluginerHash sync.RWMutex
}

// PluginerHash calls PluginerHashFunc.
func (mock *HasherMock) PluginerHash(config interface{}) (string, error) {
	if mock.PluginerHashFunc == nil {
		panic("HasherMock.PluginerHashFunc: method is nil but Hasher.PluginerHash was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockPluginerHash.Lock()
	mock.calls.PluginerHash = append(mock.calls.PluginerHash, callInfo)
	mock.lockPluginerHash.Unlock()
	return mock.PluginerHashFunc(config)
}

// PluginerHashCalls gets all the calls that were made to PluginerHash.
// Check the length with:
//     len(mockedHasher.PluginerHashCalls())
func (mock *HasherMock) PluginerHashCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockPluginerHash.RLock()
	calls = mock.calls.PluginerHash
	mock.lockPluginerHash.RUnlock()
	return calls
}

// Ensure, that NewPluginererMock does implement NewPluginerer.
// If this is not the case, regenerate this file with moq.
var _ NewPluginerer = &NewPluginererMock{}

// NewPluginererMock is a mock implementation of NewPluginerer.
//
//     func TestSomethingThatUsesNewPluginerer(t *testing.T) {
//
//         // make and configure a mocked NewPluginerer
//         mockedNewPluginerer := &NewPluginererMock{
//             NewPluginerFunc: func(config interface{}) (Pluginer, error) {
// 	               panic("mock out the NewPluginer method")
//             },
//             PluginerHashFunc: func(config interface{}) (string, error) {
// 	               panic("mock out the PluginerHash method")
//             },
//         }
//
//         // use mockedNewPluginerer in code that requires NewPluginerer
//         // and then make assertions.
//
//     }
type NewPluginererMock struct {
	// NewPluginerFunc mocks the NewPluginer method.
	NewPluginerFunc func(config interface{}) (Pluginer, error)

	// PluginerHashFunc mocks the PluginerHash method.
	PluginerHashFunc func(config interface{}) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewPluginer holds details about calls to the NewPluginer method.
		NewPluginer []struct {
			// Config is the config argument value.
			Config interface{}
		}
		// PluginerHash holds details about calls to the PluginerHash method.
		PluginerHash []struct {
			// Config is the config argument value.
			Config interface{}
		}
	}
	lockNewPluginer  sync.RWMutex
	lockPluginerHash sync.RWMutex
}

// NewPluginer calls NewPluginerFunc.
func (mock *NewPluginererMock) NewPluginer(config interface{}) (Pluginer, error) {
	if mock.NewPluginerFunc == nil {
		panic("NewPluginererMock.NewPluginerFunc: method is nil but NewPluginerer.NewPluginer was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockNewPluginer.Lock()
	mock.calls.NewPluginer = append(mock.calls.NewPluginer, callInfo)
	mock.lockNewPluginer.Unlock()
	return mock.NewPluginerFunc(config)
}

// NewPluginerCalls gets all the calls that were made to NewPluginer.
// Check the length with:
//     len(mockedNewPluginerer.NewPluginerCalls())
func (mock *NewPluginererMock) NewPluginerCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockNewPluginer.RLock()
	calls = mock.calls.NewPluginer
	mock.lockNewPluginer.RUnlock()
	return calls
}

// PluginerHash calls PluginerHashFunc.
func (mock *NewPluginererMock) PluginerHash(config interface{}) (string, error) {
	if mock.PluginerHashFunc == nil {
		panic("NewPluginererMock.PluginerHashFunc: method is nil but NewPluginerer.PluginerHash was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockPluginerHash.Lock()
	mock.calls.PluginerHash = append(mock.calls.PluginerHash, callInfo)
	mock.lockPluginerHash.Unlock()
	return mock.PluginerHashFunc(config)
}

// PluginerHashCalls gets all the calls that were made to PluginerHash.
// Check the length with:
//     len(mockedNewPluginerer.PluginerHashCalls())
func (mock *NewPluginererMock) PluginerHashCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockPluginerHash.RLock()
	calls = mock.calls.PluginerHash
	mock.lockPluginerHash.RUnlock()
	return calls
}

// Ensure, that PluginerMock does implement Pluginer.
// If this is not the case, regenerate this file with moq.
var _ Pluginer = &PluginerMock{}

// PluginerMock is a mock implementation of Pluginer.
//
//     func TestSomethingThatUsesPluginer(t *testing.T) {
//
//         // make and configure a mocked Pluginer
//         mockedPluginer := &PluginerMock{
//             CommitIDFunc: func() string {
// 	               panic("mock out the CommitID method")
//             },
//             ConfigFunc: func() string {
// 	               panic("mock out the Config method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//             SupportedTypesFunc: func() Bitmask {
// 	               panic("mock out the SupportedTypes method")
//             },
//             VersionFunc: func() string {
// 	               panic("mock out the Version method")
//             },
//         }
//
//         // use mockedPluginer in code that requires Pluginer
//         // and then make assertions.
//
//     }
type PluginerMock struct {
	// CommitIDFunc mocks the CommitID method.
	CommitIDFunc func() string

	// ConfigFunc mocks the Config method.
	ConfigFunc func() string

	// NameFunc mocks the Name method.
	NameFunc func() string

	// SupportedTypesFunc mocks the SupportedTypes method.
	SupportedTypesFunc func() Bitmask

	// VersionFunc mocks the Version method.
	VersionFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// CommitID holds details about calls to the CommitID method.
		CommitID []struct {
		}
		// Config holds details about calls to the Config method.
		Config []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// SupportedTypes holds details about calls to the SupportedTypes method.
		SupportedTypes []struct {
		}
		// Version holds details about calls to the Version method.
		Version []struct {
		}
	}
	lockCommitID       sync.RWMutex
	lockConfig         sync.RWMutex
	lockName           sync.RWMutex
	lockSupportedTypes sync.RWMutex
	lockVersion        sync.RWMutex
}

// CommitID calls CommitIDFunc.
func (mock *PluginerMock) CommitID() string {
	if mock.CommitIDFunc == nil {
		panic("PluginerMock.CommitIDFunc: method is nil but Pluginer.CommitID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommitID.Lock()
	mock.calls.CommitID = append(mock.calls.CommitID, callInfo)
	mock.lockCommitID.Unlock()
	return mock.CommitIDFunc()
}

// CommitIDCalls gets all the calls that were made to CommitID.
// Check the length with:
//     len(mockedPluginer.CommitIDCalls())
func (mock *PluginerMock) CommitIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommitID.RLock()
	calls = mock.calls.CommitID
	mock.lockCommitID.RUnlock()
	return calls
}

// Config calls ConfigFunc.
func (mock *PluginerMock) Config() string {
	if mock.ConfigFunc == nil {
		panic("PluginerMock.ConfigFunc: method is nil but Pluginer.Config was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConfig.Lock()
	mock.calls.Config = append(mock.calls.Config, callInfo)
	mock.lockConfig.Unlock()
	return mock.ConfigFunc()
}

// ConfigCalls gets all the calls that were made to Config.
// Check the length with:
//     len(mockedPluginer.ConfigCalls())
func (mock *PluginerMock) ConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConfig.RLock()
	calls = mock.calls.Config
	mock.lockConfig.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *PluginerMock) Name() string {
	if mock.NameFunc == nil {
		panic("PluginerMock.NameFunc: method is nil but Pluginer.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedPluginer.NameCalls())
func (mock *PluginerMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// SupportedTypes calls SupportedTypesFunc.
func (mock *PluginerMock) SupportedTypes() Bitmask {
	if mock.SupportedTypesFunc == nil {
		panic("PluginerMock.SupportedTypesFunc: method is nil but Pluginer.SupportedTypes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSupportedTypes.Lock()
	mock.calls.SupportedTypes = append(mock.calls.SupportedTypes, callInfo)
	mock.lockSupportedTypes.Unlock()
	return mock.SupportedTypesFunc()
}

// SupportedTypesCalls gets all the calls that were made to SupportedTypes.
// Check the length with:
//     len(mockedPluginer.SupportedTypesCalls())
func (mock *PluginerMock) SupportedTypesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSupportedTypes.RLock()
	calls = mock.calls.SupportedTypes
	mock.lockSupportedTypes.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *PluginerMock) Version() string {
	if mock.VersionFunc == nil {
		panic("PluginerMock.VersionFunc: method is nil but Pluginer.Version was just called")
	}
	callInfo := struct {
	}{}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc()
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//     len(mockedPluginer.VersionCalls())
func (mock *PluginerMock) VersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
