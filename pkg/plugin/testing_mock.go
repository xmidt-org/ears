// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package plugin

import (
	"sync"
)

// Ensure, that NewPluginererMock does implement NewPluginerer.
// If this is not the case, regenerate this file with moq.
var _ NewPluginerer = &NewPluginererMock{}

// NewPluginererMock is a mock implementation of NewPluginerer.
//
//     func TestSomethingThatUsesNewPluginerer(t *testing.T) {
//
//         // make and configure a mocked NewPluginerer
//         mockedNewPluginerer := &NewPluginererMock{
//             NewPluginerFunc: func(config string) (Pluginer, error) {
// 	               panic("mock out the NewPluginer method")
//             },
//         }
//
//         // use mockedNewPluginerer in code that requires NewPluginerer
//         // and then make assertions.
//
//     }
type NewPluginererMock struct {
	// NewPluginerFunc mocks the NewPluginer method.
	NewPluginerFunc func(config string) (Pluginer, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewPluginer holds details about calls to the NewPluginer method.
		NewPluginer []struct {
			// Config is the config argument value.
			Config string
		}
	}
	lockNewPluginer sync.RWMutex
}

// NewPluginer calls NewPluginerFunc.
func (mock *NewPluginererMock) NewPluginer(config string) (Pluginer, error) {
	if mock.NewPluginerFunc == nil {
		panic("NewPluginererMock.NewPluginerFunc: method is nil but NewPluginerer.NewPluginer was just called")
	}
	callInfo := struct {
		Config string
	}{
		Config: config,
	}
	mock.lockNewPluginer.Lock()
	mock.calls.NewPluginer = append(mock.calls.NewPluginer, callInfo)
	mock.lockNewPluginer.Unlock()
	return mock.NewPluginerFunc(config)
}

// NewPluginerCalls gets all the calls that were made to NewPluginer.
// Check the length with:
//     len(mockedNewPluginerer.NewPluginerCalls())
func (mock *NewPluginererMock) NewPluginerCalls() []struct {
	Config string
} {
	var calls []struct {
		Config string
	}
	mock.lockNewPluginer.RLock()
	calls = mock.calls.NewPluginer
	mock.lockNewPluginer.RUnlock()
	return calls
}

// Ensure, that PluginerMock does implement Pluginer.
// If this is not the case, regenerate this file with moq.
var _ Pluginer = &PluginerMock{}

// PluginerMock is a mock implementation of Pluginer.
//
//     func TestSomethingThatUsesPluginer(t *testing.T) {
//
//         // make and configure a mocked Pluginer
//         mockedPluginer := &PluginerMock{
//             ConfigFunc: func() string {
// 	               panic("mock out the Config method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//             VersionFunc: func() string {
// 	               panic("mock out the Version method")
//             },
//         }
//
//         // use mockedPluginer in code that requires Pluginer
//         // and then make assertions.
//
//     }
type PluginerMock struct {
	// ConfigFunc mocks the Config method.
	ConfigFunc func() string

	// NameFunc mocks the Name method.
	NameFunc func() string

	// VersionFunc mocks the Version method.
	VersionFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Config holds details about calls to the Config method.
		Config []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// Version holds details about calls to the Version method.
		Version []struct {
		}
	}
	lockConfig  sync.RWMutex
	lockName    sync.RWMutex
	lockVersion sync.RWMutex
}

// Config calls ConfigFunc.
func (mock *PluginerMock) Config() string {
	if mock.ConfigFunc == nil {
		panic("PluginerMock.ConfigFunc: method is nil but Pluginer.Config was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConfig.Lock()
	mock.calls.Config = append(mock.calls.Config, callInfo)
	mock.lockConfig.Unlock()
	return mock.ConfigFunc()
}

// ConfigCalls gets all the calls that were made to Config.
// Check the length with:
//     len(mockedPluginer.ConfigCalls())
func (mock *PluginerMock) ConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConfig.RLock()
	calls = mock.calls.Config
	mock.lockConfig.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *PluginerMock) Name() string {
	if mock.NameFunc == nil {
		panic("PluginerMock.NameFunc: method is nil but Pluginer.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedPluginer.NameCalls())
func (mock *PluginerMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *PluginerMock) Version() string {
	if mock.VersionFunc == nil {
		panic("PluginerMock.VersionFunc: method is nil but Pluginer.Version was just called")
	}
	callInfo := struct {
	}{}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc()
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//     len(mockedPluginer.VersionCalls())
func (mock *PluginerMock) VersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
