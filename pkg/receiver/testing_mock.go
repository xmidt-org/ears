// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package receiver

import (
	"context"
	"sync"
)

// Ensure, that HasherMock does implement Hasher.
// If this is not the case, regenerate this file with moq.
var _ Hasher = &HasherMock{}

// HasherMock is a mock implementation of Hasher.
//
//     func TestSomethingThatUsesHasher(t *testing.T) {
//
//         // make and configure a mocked Hasher
//         mockedHasher := &HasherMock{
//             ReceiverHashFunc: func(config string) (string, error) {
// 	               panic("mock out the ReceiverHash method")
//             },
//         }
//
//         // use mockedHasher in code that requires Hasher
//         // and then make assertions.
//
//     }
type HasherMock struct {
	// ReceiverHashFunc mocks the ReceiverHash method.
	ReceiverHashFunc func(config string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// ReceiverHash holds details about calls to the ReceiverHash method.
		ReceiverHash []struct {
			// Config is the config argument value.
			Config string
		}
	}
	lockReceiverHash sync.RWMutex
}

// ReceiverHash calls ReceiverHashFunc.
func (mock *HasherMock) ReceiverHash(config string) (string, error) {
	if mock.ReceiverHashFunc == nil {
		panic("HasherMock.ReceiverHashFunc: method is nil but Hasher.ReceiverHash was just called")
	}
	callInfo := struct {
		Config string
	}{
		Config: config,
	}
	mock.lockReceiverHash.Lock()
	mock.calls.ReceiverHash = append(mock.calls.ReceiverHash, callInfo)
	mock.lockReceiverHash.Unlock()
	return mock.ReceiverHashFunc(config)
}

// ReceiverHashCalls gets all the calls that were made to ReceiverHash.
// Check the length with:
//     len(mockedHasher.ReceiverHashCalls())
func (mock *HasherMock) ReceiverHashCalls() []struct {
	Config string
} {
	var calls []struct {
		Config string
	}
	mock.lockReceiverHash.RLock()
	calls = mock.calls.ReceiverHash
	mock.lockReceiverHash.RUnlock()
	return calls
}

// Ensure, that NewReceivererMock does implement NewReceiverer.
// If this is not the case, regenerate this file with moq.
var _ NewReceiverer = &NewReceivererMock{}

// NewReceivererMock is a mock implementation of NewReceiverer.
//
//     func TestSomethingThatUsesNewReceiverer(t *testing.T) {
//
//         // make and configure a mocked NewReceiverer
//         mockedNewReceiverer := &NewReceivererMock{
//             NewReceiverFunc: func(config string) (Receiver, error) {
// 	               panic("mock out the NewReceiver method")
//             },
//             ReceiverHashFunc: func(config string) (string, error) {
// 	               panic("mock out the ReceiverHash method")
//             },
//         }
//
//         // use mockedNewReceiverer in code that requires NewReceiverer
//         // and then make assertions.
//
//     }
type NewReceivererMock struct {
	// NewReceiverFunc mocks the NewReceiver method.
	NewReceiverFunc func(config string) (Receiver, error)

	// ReceiverHashFunc mocks the ReceiverHash method.
	ReceiverHashFunc func(config string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewReceiver holds details about calls to the NewReceiver method.
		NewReceiver []struct {
			// Config is the config argument value.
			Config string
		}
		// ReceiverHash holds details about calls to the ReceiverHash method.
		ReceiverHash []struct {
			// Config is the config argument value.
			Config string
		}
	}
	lockNewReceiver  sync.RWMutex
	lockReceiverHash sync.RWMutex
}

// NewReceiver calls NewReceiverFunc.
func (mock *NewReceivererMock) NewReceiver(config string) (Receiver, error) {
	if mock.NewReceiverFunc == nil {
		panic("NewReceivererMock.NewReceiverFunc: method is nil but NewReceiverer.NewReceiver was just called")
	}
	callInfo := struct {
		Config string
	}{
		Config: config,
	}
	mock.lockNewReceiver.Lock()
	mock.calls.NewReceiver = append(mock.calls.NewReceiver, callInfo)
	mock.lockNewReceiver.Unlock()
	return mock.NewReceiverFunc(config)
}

// NewReceiverCalls gets all the calls that were made to NewReceiver.
// Check the length with:
//     len(mockedNewReceiverer.NewReceiverCalls())
func (mock *NewReceivererMock) NewReceiverCalls() []struct {
	Config string
} {
	var calls []struct {
		Config string
	}
	mock.lockNewReceiver.RLock()
	calls = mock.calls.NewReceiver
	mock.lockNewReceiver.RUnlock()
	return calls
}

// ReceiverHash calls ReceiverHashFunc.
func (mock *NewReceivererMock) ReceiverHash(config string) (string, error) {
	if mock.ReceiverHashFunc == nil {
		panic("NewReceivererMock.ReceiverHashFunc: method is nil but NewReceiverer.ReceiverHash was just called")
	}
	callInfo := struct {
		Config string
	}{
		Config: config,
	}
	mock.lockReceiverHash.Lock()
	mock.calls.ReceiverHash = append(mock.calls.ReceiverHash, callInfo)
	mock.lockReceiverHash.Unlock()
	return mock.ReceiverHashFunc(config)
}

// ReceiverHashCalls gets all the calls that were made to ReceiverHash.
// Check the length with:
//     len(mockedNewReceiverer.ReceiverHashCalls())
func (mock *NewReceivererMock) ReceiverHashCalls() []struct {
	Config string
} {
	var calls []struct {
		Config string
	}
	mock.lockReceiverHash.RLock()
	calls = mock.calls.ReceiverHash
	mock.lockReceiverHash.RUnlock()
	return calls
}

// Ensure, that ReceiverMock does implement Receiver.
// If this is not the case, regenerate this file with moq.
var _ Receiver = &ReceiverMock{}

// ReceiverMock is a mock implementation of Receiver.
//
//     func TestSomethingThatUsesReceiver(t *testing.T) {
//
//         // make and configure a mocked Receiver
//         mockedReceiver := &ReceiverMock{
//             ReceiveFunc: func(ctx context.Context, next NextFn) error {
// 	               panic("mock out the Receive method")
//             },
//         }
//
//         // use mockedReceiver in code that requires Receiver
//         // and then make assertions.
//
//     }
type ReceiverMock struct {
	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func(ctx context.Context, next NextFn) error

	// calls tracks calls to the methods.
	calls struct {
		// Receive holds details about calls to the Receive method.
		Receive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Next is the next argument value.
			Next NextFn
		}
	}
	lockReceive sync.RWMutex
}

// Receive calls ReceiveFunc.
func (mock *ReceiverMock) Receive(ctx context.Context, next NextFn) error {
	if mock.ReceiveFunc == nil {
		panic("ReceiverMock.ReceiveFunc: method is nil but Receiver.Receive was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Next NextFn
	}{
		Ctx:  ctx,
		Next: next,
	}
	mock.lockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	mock.lockReceive.Unlock()
	return mock.ReceiveFunc(ctx, next)
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedReceiver.ReceiveCalls())
func (mock *ReceiverMock) ReceiveCalls() []struct {
	Ctx  context.Context
	Next NextFn
} {
	var calls []struct {
		Ctx  context.Context
		Next NextFn
	}
	mock.lockReceive.RLock()
	calls = mock.calls.Receive
	mock.lockReceive.RUnlock()
	return calls
}
