// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package filter

import (
	"context"
	"github.com/xmidt-org/ears/pkg/event"
	"sync"
)

// Ensure, that HasherMock does implement Hasher.
// If this is not the case, regenerate this file with moq.
var _ Hasher = &HasherMock{}

// HasherMock is a mock implementation of Hasher.
//
//     func TestSomethingThatUsesHasher(t *testing.T) {
//
//         // make and configure a mocked Hasher
//         mockedHasher := &HasherMock{
//             FiltererHashFunc: func(config interface{}) (string, error) {
// 	               panic("mock out the FiltererHash method")
//             },
//         }
//
//         // use mockedHasher in code that requires Hasher
//         // and then make assertions.
//
//     }
type HasherMock struct {
	// FiltererHashFunc mocks the FiltererHash method.
	FiltererHashFunc func(config interface{}) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// FiltererHash holds details about calls to the FiltererHash method.
		FiltererHash []struct {
			// Config is the config argument value.
			Config interface{}
		}
	}
	lockFiltererHash sync.RWMutex
}

// FiltererHash calls FiltererHashFunc.
func (mock *HasherMock) FiltererHash(config interface{}) (string, error) {
	if mock.FiltererHashFunc == nil {
		panic("HasherMock.FiltererHashFunc: method is nil but Hasher.FiltererHash was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockFiltererHash.Lock()
	mock.calls.FiltererHash = append(mock.calls.FiltererHash, callInfo)
	mock.lockFiltererHash.Unlock()
	return mock.FiltererHashFunc(config)
}

// FiltererHashCalls gets all the calls that were made to FiltererHash.
// Check the length with:
//     len(mockedHasher.FiltererHashCalls())
func (mock *HasherMock) FiltererHashCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockFiltererHash.RLock()
	calls = mock.calls.FiltererHash
	mock.lockFiltererHash.RUnlock()
	return calls
}

// Ensure, that NewFiltererMock does implement NewFilterer.
// If this is not the case, regenerate this file with moq.
var _ NewFilterer = &NewFiltererMock{}

// NewFiltererMock is a mock implementation of NewFilterer.
//
//     func TestSomethingThatUsesNewFilterer(t *testing.T) {
//
//         // make and configure a mocked NewFilterer
//         mockedNewFilterer := &NewFiltererMock{
//             FiltererHashFunc: func(config interface{}) (string, error) {
// 	               panic("mock out the FiltererHash method")
//             },
//             NewFiltererFunc: func(config interface{}) (Filterer, error) {
// 	               panic("mock out the NewFilterer method")
//             },
//         }
//
//         // use mockedNewFilterer in code that requires NewFilterer
//         // and then make assertions.
//
//     }
type NewFiltererMock struct {
	// FiltererHashFunc mocks the FiltererHash method.
	FiltererHashFunc func(config interface{}) (string, error)

	// NewFiltererFunc mocks the NewFilterer method.
	NewFiltererFunc func(config interface{}) (Filterer, error)

	// calls tracks calls to the methods.
	calls struct {
		// FiltererHash holds details about calls to the FiltererHash method.
		FiltererHash []struct {
			// Config is the config argument value.
			Config interface{}
		}
		// NewFilterer holds details about calls to the NewFilterer method.
		NewFilterer []struct {
			// Config is the config argument value.
			Config interface{}
		}
	}
	lockFiltererHash sync.RWMutex
	lockNewFilterer  sync.RWMutex
}

// FiltererHash calls FiltererHashFunc.
func (mock *NewFiltererMock) FiltererHash(config interface{}) (string, error) {
	if mock.FiltererHashFunc == nil {
		panic("NewFiltererMock.FiltererHashFunc: method is nil but NewFilterer.FiltererHash was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockFiltererHash.Lock()
	mock.calls.FiltererHash = append(mock.calls.FiltererHash, callInfo)
	mock.lockFiltererHash.Unlock()
	return mock.FiltererHashFunc(config)
}

// FiltererHashCalls gets all the calls that were made to FiltererHash.
// Check the length with:
//     len(mockedNewFilterer.FiltererHashCalls())
func (mock *NewFiltererMock) FiltererHashCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockFiltererHash.RLock()
	calls = mock.calls.FiltererHash
	mock.lockFiltererHash.RUnlock()
	return calls
}

// NewFilterer calls NewFiltererFunc.
func (mock *NewFiltererMock) NewFilterer(config interface{}) (Filterer, error) {
	if mock.NewFiltererFunc == nil {
		panic("NewFiltererMock.NewFiltererFunc: method is nil but NewFilterer.NewFilterer was just called")
	}
	callInfo := struct {
		Config interface{}
	}{
		Config: config,
	}
	mock.lockNewFilterer.Lock()
	mock.calls.NewFilterer = append(mock.calls.NewFilterer, callInfo)
	mock.lockNewFilterer.Unlock()
	return mock.NewFiltererFunc(config)
}

// NewFiltererCalls gets all the calls that were made to NewFilterer.
// Check the length with:
//     len(mockedNewFilterer.NewFiltererCalls())
func (mock *NewFiltererMock) NewFiltererCalls() []struct {
	Config interface{}
} {
	var calls []struct {
		Config interface{}
	}
	mock.lockNewFilterer.RLock()
	calls = mock.calls.NewFilterer
	mock.lockNewFilterer.RUnlock()
	return calls
}

// Ensure, that FiltererMock does implement Filterer.
// If this is not the case, regenerate this file with moq.
var _ Filterer = &FiltererMock{}

// FiltererMock is a mock implementation of Filterer.
//
//     func TestSomethingThatUsesFilterer(t *testing.T) {
//
//         // make and configure a mocked Filterer
//         mockedFilterer := &FiltererMock{
//             FilterFunc: func(ctx context.Context, e event.Event) ([]event.Event, error) {
// 	               panic("mock out the Filter method")
//             },
//         }
//
//         // use mockedFilterer in code that requires Filterer
//         // and then make assertions.
//
//     }
type FiltererMock struct {
	// FilterFunc mocks the Filter method.
	FilterFunc func(ctx context.Context, e event.Event) ([]event.Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// Filter holds details about calls to the Filter method.
		Filter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// E is the e argument value.
			E event.Event
		}
	}
	lockFilter sync.RWMutex
}

// Filter calls FilterFunc.
func (mock *FiltererMock) Filter(ctx context.Context, e event.Event) ([]event.Event, error) {
	if mock.FilterFunc == nil {
		panic("FiltererMock.FilterFunc: method is nil but Filterer.Filter was just called")
	}
	callInfo := struct {
		Ctx context.Context
		E   event.Event
	}{
		Ctx: ctx,
		E:   e,
	}
	mock.lockFilter.Lock()
	mock.calls.Filter = append(mock.calls.Filter, callInfo)
	mock.lockFilter.Unlock()
	return mock.FilterFunc(ctx, e)
}

// FilterCalls gets all the calls that were made to Filter.
// Check the length with:
//     len(mockedFilterer.FilterCalls())
func (mock *FiltererMock) FilterCalls() []struct {
	Ctx context.Context
	E   event.Event
} {
	var calls []struct {
		Ctx context.Context
		E   event.Event
	}
	mock.lockFilter.RLock()
	calls = mock.calls.Filter
	mock.lockFilter.RUnlock()
	return calls
}
