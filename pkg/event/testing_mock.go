// Licensed to Comcast Cable Communications Management, LLC under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Comcast Cable Communications Management, LLC licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package event

import (
	"sync"
)

var (
	lockEventMockAck        sync.RWMutex
	lockEventMockDup        sync.RWMutex
	lockEventMockPayload    sync.RWMutex
	lockEventMockSetPayload sync.RWMutex
)

// Ensure, that EventMock does implement Event.
// If this is not the case, regenerate this file with moq.
var _ Event = &EventMock{}

// EventMock is a mock implementation of Event.
//
//     func TestSomethingThatUsesEvent(t *testing.T) {
//
//         // make and configure a mocked Event
//         mockedEvent := &EventMock{
//             AckFunc: func()  {
// 	               panic("mock out the Ack method")
//             },
//             DupFunc: func() (Event, error) {
// 	               panic("mock out the Dup method")
//             },
//             PayloadFunc: func() interface{} {
// 	               panic("mock out the Payload method")
//             },
//             SetPayloadFunc: func(payload interface{}) error {
// 	               panic("mock out the SetPayload method")
//             },
//         }
//
//         // use mockedEvent in code that requires Event
//         // and then make assertions.
//
//     }
type EventMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func()

	// DupFunc mocks the Dup method.
	DupFunc func() (Event, error)

	// PayloadFunc mocks the Payload method.
	PayloadFunc func() interface{}

	// SetPayloadFunc mocks the SetPayload method.
	SetPayloadFunc func(payload interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
		}
		// Dup holds details about calls to the Dup method.
		Dup []struct {
		}
		// Payload holds details about calls to the Payload method.
		Payload []struct {
		}
		// SetPayload holds details about calls to the SetPayload method.
		SetPayload []struct {
			// Payload is the payload argument value.
			Payload interface{}
		}
	}
}

// Ack calls AckFunc.
func (mock *EventMock) Ack() {
	if mock.AckFunc == nil {
		panic("EventMock.AckFunc: method is nil but Event.Ack was just called")
	}
	callInfo := struct {
	}{}
	lockEventMockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	lockEventMockAck.Unlock()
	mock.AckFunc()
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//     len(mockedEvent.AckCalls())
func (mock *EventMock) AckCalls() []struct {
} {
	var calls []struct {
	}
	lockEventMockAck.RLock()
	calls = mock.calls.Ack
	lockEventMockAck.RUnlock()
	return calls
}

// Dup calls DupFunc.
func (mock *EventMock) Dup() (Event, error) {
	if mock.DupFunc == nil {
		panic("EventMock.DupFunc: method is nil but Event.Dup was just called")
	}
	callInfo := struct {
	}{}
	lockEventMockDup.Lock()
	mock.calls.Dup = append(mock.calls.Dup, callInfo)
	lockEventMockDup.Unlock()
	return mock.DupFunc()
}

// DupCalls gets all the calls that were made to Dup.
// Check the length with:
//     len(mockedEvent.DupCalls())
func (mock *EventMock) DupCalls() []struct {
} {
	var calls []struct {
	}
	lockEventMockDup.RLock()
	calls = mock.calls.Dup
	lockEventMockDup.RUnlock()
	return calls
}

// Payload calls PayloadFunc.
func (mock *EventMock) Payload() interface{} {
	if mock.PayloadFunc == nil {
		panic("EventMock.PayloadFunc: method is nil but Event.Payload was just called")
	}
	callInfo := struct {
	}{}
	lockEventMockPayload.Lock()
	mock.calls.Payload = append(mock.calls.Payload, callInfo)
	lockEventMockPayload.Unlock()
	return mock.PayloadFunc()
}

// PayloadCalls gets all the calls that were made to Payload.
// Check the length with:
//     len(mockedEvent.PayloadCalls())
func (mock *EventMock) PayloadCalls() []struct {
} {
	var calls []struct {
	}
	lockEventMockPayload.RLock()
	calls = mock.calls.Payload
	lockEventMockPayload.RUnlock()
	return calls
}

// SetPayload calls SetPayloadFunc.
func (mock *EventMock) SetPayload(payload interface{}) error {
	if mock.SetPayloadFunc == nil {
		panic("EventMock.SetPayloadFunc: method is nil but Event.SetPayload was just called")
	}
	callInfo := struct {
		Payload interface{}
	}{
		Payload: payload,
	}
	lockEventMockSetPayload.Lock()
	mock.calls.SetPayload = append(mock.calls.SetPayload, callInfo)
	lockEventMockSetPayload.Unlock()
	return mock.SetPayloadFunc(payload)
}

// SetPayloadCalls gets all the calls that were made to SetPayload.
// Check the length with:
//     len(mockedEvent.SetPayloadCalls())
func (mock *EventMock) SetPayloadCalls() []struct {
	Payload interface{}
} {
	var calls []struct {
		Payload interface{}
	}
	lockEventMockSetPayload.RLock()
	calls = mock.calls.SetPayload
	lockEventMockSetPayload.RUnlock()
	return calls
}

var (
	lockNewEventererMockNewEvent sync.RWMutex
)

// Ensure, that NewEventererMock does implement NewEventerer.
// If this is not the case, regenerate this file with moq.
var _ NewEventerer = &NewEventererMock{}

// NewEventererMock is a mock implementation of NewEventerer.
//
//     func TestSomethingThatUsesNewEventerer(t *testing.T) {
//
//         // make and configure a mocked NewEventerer
//         mockedNewEventerer := &NewEventererMock{
//             NewEventFunc: func(payload interface{}) (Event, error) {
// 	               panic("mock out the NewEvent method")
//             },
//         }
//
//         // use mockedNewEventerer in code that requires NewEventerer
//         // and then make assertions.
//
//     }
type NewEventererMock struct {
	// NewEventFunc mocks the NewEvent method.
	NewEventFunc func(payload interface{}) (Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewEvent holds details about calls to the NewEvent method.
		NewEvent []struct {
			// Payload is the payload argument value.
			Payload interface{}
		}
	}
}

// NewEvent calls NewEventFunc.
func (mock *NewEventererMock) NewEvent(payload interface{}) (Event, error) {
	if mock.NewEventFunc == nil {
		panic("NewEventererMock.NewEventFunc: method is nil but NewEventerer.NewEvent was just called")
	}
	callInfo := struct {
		Payload interface{}
	}{
		Payload: payload,
	}
	lockNewEventererMockNewEvent.Lock()
	mock.calls.NewEvent = append(mock.calls.NewEvent, callInfo)
	lockNewEventererMockNewEvent.Unlock()
	return mock.NewEventFunc(payload)
}

// NewEventCalls gets all the calls that were made to NewEvent.
// Check the length with:
//     len(mockedNewEventerer.NewEventCalls())
func (mock *NewEventererMock) NewEventCalls() []struct {
	Payload interface{}
} {
	var calls []struct {
		Payload interface{}
	}
	lockNewEventererMockNewEvent.RLock()
	calls = mock.calls.NewEvent
	lockNewEventererMockNewEvent.RUnlock()
	return calls
}
