// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package event

import (
	"sync"
)

// Ensure, that EventMock does implement Event.
// If this is not the case, regenerate this file with moq.
var _ Event = &EventMock{}

// EventMock is a mock implementation of Event.
//
//     func TestSomethingThatUsesEvent(t *testing.T) {
//
//         // make and configure a mocked Event
//         mockedEvent := &EventMock{
//             AckFunc: func()  {
// 	               panic("mock out the Ack method")
//             },
//             DupFunc: func() (Event, error) {
// 	               panic("mock out the Dup method")
//             },
//             PayloadFunc: func() interface{} {
// 	               panic("mock out the Payload method")
//             },
//             SetPayloadFunc: func(payload interface{}) error {
// 	               panic("mock out the SetPayload method")
//             },
//         }
//
//         // use mockedEvent in code that requires Event
//         // and then make assertions.
//
//     }
type EventMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func()

	// DupFunc mocks the Dup method.
	DupFunc func() (Event, error)

	// PayloadFunc mocks the Payload method.
	PayloadFunc func() interface{}

	// SetPayloadFunc mocks the SetPayload method.
	SetPayloadFunc func(payload interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
		}
		// Dup holds details about calls to the Dup method.
		Dup []struct {
		}
		// Payload holds details about calls to the Payload method.
		Payload []struct {
		}
		// SetPayload holds details about calls to the SetPayload method.
		SetPayload []struct {
			// Payload is the payload argument value.
			Payload interface{}
		}
	}
	lockAck        sync.RWMutex
	lockDup        sync.RWMutex
	lockPayload    sync.RWMutex
	lockSetPayload sync.RWMutex
}

// Ack calls AckFunc.
func (mock *EventMock) Ack() {
	if mock.AckFunc == nil {
		panic("EventMock.AckFunc: method is nil but Event.Ack was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc()
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//     len(mockedEvent.AckCalls())
func (mock *EventMock) AckCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// Dup calls DupFunc.
func (mock *EventMock) Dup() (Event, error) {
	if mock.DupFunc == nil {
		panic("EventMock.DupFunc: method is nil but Event.Dup was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDup.Lock()
	mock.calls.Dup = append(mock.calls.Dup, callInfo)
	mock.lockDup.Unlock()
	return mock.DupFunc()
}

// DupCalls gets all the calls that were made to Dup.
// Check the length with:
//     len(mockedEvent.DupCalls())
func (mock *EventMock) DupCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDup.RLock()
	calls = mock.calls.Dup
	mock.lockDup.RUnlock()
	return calls
}

// Payload calls PayloadFunc.
func (mock *EventMock) Payload() interface{} {
	if mock.PayloadFunc == nil {
		panic("EventMock.PayloadFunc: method is nil but Event.Payload was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPayload.Lock()
	mock.calls.Payload = append(mock.calls.Payload, callInfo)
	mock.lockPayload.Unlock()
	return mock.PayloadFunc()
}

// PayloadCalls gets all the calls that were made to Payload.
// Check the length with:
//     len(mockedEvent.PayloadCalls())
func (mock *EventMock) PayloadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPayload.RLock()
	calls = mock.calls.Payload
	mock.lockPayload.RUnlock()
	return calls
}

// SetPayload calls SetPayloadFunc.
func (mock *EventMock) SetPayload(payload interface{}) error {
	if mock.SetPayloadFunc == nil {
		panic("EventMock.SetPayloadFunc: method is nil but Event.SetPayload was just called")
	}
	callInfo := struct {
		Payload interface{}
	}{
		Payload: payload,
	}
	mock.lockSetPayload.Lock()
	mock.calls.SetPayload = append(mock.calls.SetPayload, callInfo)
	mock.lockSetPayload.Unlock()
	return mock.SetPayloadFunc(payload)
}

// SetPayloadCalls gets all the calls that were made to SetPayload.
// Check the length with:
//     len(mockedEvent.SetPayloadCalls())
func (mock *EventMock) SetPayloadCalls() []struct {
	Payload interface{}
} {
	var calls []struct {
		Payload interface{}
	}
	mock.lockSetPayload.RLock()
	calls = mock.calls.SetPayload
	mock.lockSetPayload.RUnlock()
	return calls
}

// Ensure, that NewEventererMock does implement NewEventerer.
// If this is not the case, regenerate this file with moq.
var _ NewEventerer = &NewEventererMock{}

// NewEventererMock is a mock implementation of NewEventerer.
//
//     func TestSomethingThatUsesNewEventerer(t *testing.T) {
//
//         // make and configure a mocked NewEventerer
//         mockedNewEventerer := &NewEventererMock{
//             NewEventFunc: func(payload interface{}) (Event, error) {
// 	               panic("mock out the NewEvent method")
//             },
//         }
//
//         // use mockedNewEventerer in code that requires NewEventerer
//         // and then make assertions.
//
//     }
type NewEventererMock struct {
	// NewEventFunc mocks the NewEvent method.
	NewEventFunc func(payload interface{}) (Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewEvent holds details about calls to the NewEvent method.
		NewEvent []struct {
			// Payload is the payload argument value.
			Payload interface{}
		}
	}
	lockNewEvent sync.RWMutex
}

// NewEvent calls NewEventFunc.
func (mock *NewEventererMock) NewEvent(payload interface{}) (Event, error) {
	if mock.NewEventFunc == nil {
		panic("NewEventererMock.NewEventFunc: method is nil but NewEventerer.NewEvent was just called")
	}
	callInfo := struct {
		Payload interface{}
	}{
		Payload: payload,
	}
	mock.lockNewEvent.Lock()
	mock.calls.NewEvent = append(mock.calls.NewEvent, callInfo)
	mock.lockNewEvent.Unlock()
	return mock.NewEventFunc(payload)
}

// NewEventCalls gets all the calls that were made to NewEvent.
// Check the length with:
//     len(mockedNewEventerer.NewEventCalls())
func (mock *NewEventererMock) NewEventCalls() []struct {
	Payload interface{}
} {
	var calls []struct {
		Payload interface{}
	}
	mock.lockNewEvent.RLock()
	calls = mock.calls.NewEvent
	mock.lockNewEvent.RUnlock()
	return calls
}
